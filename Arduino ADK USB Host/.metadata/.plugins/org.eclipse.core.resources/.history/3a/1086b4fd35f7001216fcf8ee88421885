/*
 * USB_Device_Implementation.cpp
 *
 *  Created on: Jul 17, 2013
 *      Author: francispapineau
 */

#include "USB_Device_Implementation.h"

void USB_DEVICE::run(){

	/**
	 * Start the state machine and push the state to start.
	 *
	 * FROM: 	LOCAL_DEVICE_SETUP
	 * TO: 		NETWORK_SETUP
	 */
	usb_state_machine.move_state_forward();

	/**
	 * Initializes the packet structs.
	 */
	_init_structs();

	/**
	 * Powers on the router.
	 */
	command_interpreter.send_cmd(USB_DEVICE_CMD, (void*)POWERON_ROUTER);

	/**
	 * Move the state machine to the ID wakeup router section of the
	 * state machine.
	 *
	 * FROM: 	NETWORK_SETUP
	 * TO: 		NETWORK_ID_REQUEST
	 */
	usb_state_machine.move_state_forward();

	/** This function sends_a wakeup call to the router and makes the
	 * router go into command polling mode. This allows the router to
	 * only react to the commands sent by the ground station and not the
	 * sensors.
	 *
	 * -> This function needs an ack before a watchdog timer expires
	 *    to continue with the setup process.
	 *
	 *	-> power_on_router();
	 * 	 1. send_wakeup_router();
	 * 	 	-> receive_router_ack();
 	 */
	command_interpreter.send_cmd(USB_DEVICE_CMD, (void*)WAKEUP_ROUTER);

	/**
	 * Makes sure that the device is ok and running
	 */
	command_interpreter.send_cmd(USB_DEVICE_CMD, (void*)PING_ROUTER);

	/**
	 * Move the state machine to the network status request state.
	 *
	 * FROM:	NETWORK_ID_REQUEST
	 * TO: 		NETWORK_STATUS_REQUEST
	 */
	usb_state_machine.move_state_forward();

	/**
	 * This function requests a router status structure. It sends a
	 * request command and polls until a structure is returned or when a
	 * watchdog timer exhaust is caught.
	 *
	 * -> This function needs an ack before a watchdog timer expires
	 *    to continue with the setup process.
	 *
  	 * 	  2. request_router_status();
  	 * 	  	-> receive_router_status();
	 */
	command_interpreter.send_cmd(USB_DEVICE_CMD, (void*)ROUTER_STATUS);

	/**
	 * Gets the router configs.
	 */
	command_interpreter.send_cmd(USB_DEVICE_CMD, (void*)ROUTER_CONFIG);

	/**
	 * Save them to eeprom address 200dec.
	 */
	nvram._savex((byte)200, 8, (void*)packet_parser._radio_configs);

	/**
	 * Move the state machine to the network map request.
	 *
	 * FROM:	NETWORK_STATUS_REQUEST
	 * TO: 		NETWORK_MAP_REQUEST
	 */
	usb_state_machine.move_state_forward();

	/**
	 * This function is very crucial to the network implementation, as
	 * it maps out the receiver and sender nodes. This function sends a
	 * generic "nmap" command, which activates a network_read() command on
	 * the router. Then in turn, the router returns a network structure,
	 * which contains enddevice information and other crucial network info.
	 *
	 * -> This function needs a message before a watchdog timer expires
	 *    to continue with the setup process.
	 *
	 *		3. request_net_map();
	 *			-> receive_nmap();
	 */
	command_interpreter.send_cmd(USB_DEVICE_CMD, (void*)REQUEST_NMAP);

	/**
	 * Move the state machine to the network sensor configs.
	 *
	 * FROM:	NETWORK_MAP_REQUEST
	 * TO: 		NETWORK_SENSOR_CONFIGS
	 */
	usb_state_machine.move_state_forward();

	/**
	 * Now that the network topology is mapped out, the follwoing command
	 * is issued to all endpoint devices (sensors) to acquire their
	 * respective specifics, such as channel IDs, speed and data types.
	 *
	 * -> This function needs a message before a watchdog timer expires
	 *    to continue with the setup process.
	 *
	 * 		4. request_sensor_channel_info();
	 * 			-> receive_channel_info();
	 */
	for(byte i = 0; i < packet_parser._nmap.number_sensors; i ++){

		//byte command[] = {REQUEST_SENSOR_CONFIG, packet_parser.};
		//command_interpreter.send_cmd(USB_DEVICE_CMD, (void*)command);
	}
	/**
	 * This function polls for an enabled sensor report generated by the
	 * user on the router, by selecting which sensor is enabled.
	 *
	 * 		5. get_user_enable_sensors();
	 * 			-> set_flags(byte sensor flags);
	 */

	//...

	/**
	 * Once the state machine gets here, it polls for data from the router
	 * and parses it into the structures.
	 */

	for(;;){

	}
}

