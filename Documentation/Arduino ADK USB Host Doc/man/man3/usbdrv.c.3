.TH "Arduino_ADK_USB_HOST/USB_HID_API/usbdrv.c" 3 "Thu Aug 15 2013" "Version 1.0" "Arduino Medical Assitive Device Base Station" \" -*- nroff -*-
.ad l
.nh
.SH NAME
Arduino_ADK_USB_HOST/USB_HID_API/usbdrv.c \- 
.SH SYNOPSIS
.br
.PP
\fC#include 'usbportability\&.h'\fP
.br
\fC#include 'usbdrv\&.h'\fP
.br
\fC#include 'oddebug\&.h'\fP
.br

.SS "Macros"

.in +1c
.ti -1c
.RI "#define \fBUSB_FLG_MSGPTR_IS_ROM\fP   (1<<6)"
.br
.ti -1c
.RI "#define \fBUSB_FLG_USE_USER_RW\fP   (1<<7)"
.br
.ti -1c
.RI "#define \fBUSB_CFG_DESCR_PROPS_STRING_0\fP   sizeof(\fBusbDescriptorString0\fP)"
.br
.ti -1c
.RI "#define \fBUSB_CFG_DESCR_PROPS_STRING_VENDOR\fP   sizeof(\fBusbDescriptorStringVendor\fP)"
.br
.ti -1c
.RI "#define \fBUSB_CFG_DESCR_PROPS_STRING_PRODUCT\fP   sizeof(\fBusbDescriptorStringDevice\fP)"
.br
.ti -1c
.RI "#define \fBUSB_CFG_DESCR_PROPS_DEVICE\fP   sizeof(\fBusbDescriptorDevice\fP)"
.br
.ti -1c
.RI "#define \fBUSB_CFG_DESCR_PROPS_CONFIGURATION\fP   sizeof(\fBusbDescriptorConfiguration\fP)"
.br
.ti -1c
.RI "#define \fBSWITCH_START\fP(cmd)   {\fBuchar\fP _cmd = cmd; if(0){"
.br
.ti -1c
.RI "#define \fBSWITCH_CASE\fP(value)   }else if(_cmd == (value)){"
.br
.ti -1c
.RI "#define \fBSWITCH_CASE2\fP(v1, v2)   }else if(_cmd == (v1) || _cmd == (v2)){"
.br
.ti -1c
.RI "#define \fBSWITCH_CASE3\fP(v1, v2, v3)   }else if(_cmd == (v1) || _cmd == (v2) || (_cmd == v3)){"
.br
.ti -1c
.RI "#define \fBSWITCH_DEFAULT\fP   }else{"
.br
.ti -1c
.RI "#define \fBSWITCH_END\fP   }}"
.br
.ti -1c
.RI "#define \fBUSB_RX_USER_HOOK\fP(\fBdata\fP, len)"
.br
.ti -1c
.RI "#define \fBUSB_SET_ADDRESS_HOOK\fP()"
.br
.ti -1c
.RI "#define \fBGET_DESCRIPTOR\fP(cfgProp, staticName)"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "\fBUSB_PUBLIC\fP void \fBusbSetInterrupt\fP (\fBuchar\fP *\fBdata\fP, \fBuchar\fP len)"
.br
.ti -1c
.RI "\fBUSB_PUBLIC\fP void \fBusbPoll\fP (void)"
.br
.ti -1c
.RI "\fBUSB_PUBLIC\fP void \fBusbInit\fP (void)"
.br
.in -1c
.SS "Variables"

.in +1c
.ti -1c
.RI "\fBuchar\fP \fBusbRxBuf\fP [2 *\fBUSB_BUFSIZE\fP]"
.br
.ti -1c
.RI "\fBuchar\fP \fBusbInputBufOffset\fP"
.br
.ti -1c
.RI "\fBuchar\fP \fBusbDeviceAddr\fP"
.br
.ti -1c
.RI "\fBuchar\fP \fBusbNewDeviceAddr\fP"
.br
.ti -1c
.RI "\fBuchar\fP \fBusbConfiguration\fP"
.br
.ti -1c
.RI "volatile \fBschar\fP \fBusbRxLen\fP"
.br
.ti -1c
.RI "\fBuchar\fP \fBusbCurrentTok\fP"
.br
.ti -1c
.RI "\fBuchar\fP \fBusbRxToken\fP"
.br
.ti -1c
.RI "volatile \fBuchar\fP \fBusbTxLen\fP = \fBUSBPID_NAK\fP"
.br
.ti -1c
.RI "\fBuchar\fP \fBusbTxBuf\fP [\fBUSB_BUFSIZE\fP]"
.br
.ti -1c
.RI "\fBusbTxStatus_t\fP \fBusbTxStatus1\fP"
.br
.ti -1c
.RI "\fBuchar\fP * \fBusbMsgPtr\fP"
.br
.ti -1c
.RI "\fBPROGMEM\fP char \fBusbDescriptorString0\fP []"
.br
.ti -1c
.RI "\fBPROGMEM\fP int \fBusbDescriptorStringVendor\fP []"
.br
.ti -1c
.RI "\fBPROGMEM\fP int \fBusbDescriptorStringDevice\fP []"
.br
.ti -1c
.RI "\fBPROGMEM\fP char \fBusbDescriptorDevice\fP []"
.br
.ti -1c
.RI "\fBPROGMEM\fP char \fBusbDescriptorConfiguration\fP []"
.br
.in -1c
.SH "Macro Definition Documentation"
.PP 
.SS "#define GET_DESCRIPTOR(cfgProp, staticName)"
\fBValue:\fP
.PP
.nf
if(cfgProp){                                    \
        if((cfgProp) & USB_PROP_IS_RAM)             \
            flags = 0;                              \
        if((cfgProp) & USB_PROP_IS_DYNAMIC){        \
            len = usbFunctionDescriptor(rq);        \
        }else{                                      \
            len = USB_PROP_LENGTH(cfgProp);         \
            usbMsgPtr = (uchar *)(staticName);      \
        }                                           \
    }
.fi
.PP
Definition at line 296 of file usbdrv\&.c\&.
.SS "#define SWITCH_CASE(value)   }else if(_cmd == (value)){"

.PP
Definition at line 275 of file usbdrv\&.c\&.
.SS "#define SWITCH_CASE2(v1, v2)   }else if(_cmd == (v1) || _cmd == (v2)){"

.PP
Definition at line 276 of file usbdrv\&.c\&.
.SS "#define SWITCH_CASE3(v1, v2, v3)   }else if(_cmd == (v1) || _cmd == (v2) || (_cmd == v3)){"

.PP
Definition at line 277 of file usbdrv\&.c\&.
.SS "#define SWITCH_DEFAULT   }else{"

.PP
Definition at line 278 of file usbdrv\&.c\&.
.SS "#define SWITCH_END   }}"

.PP
Definition at line 279 of file usbdrv\&.c\&.
.SS "#define SWITCH_START(cmd)   {\fBuchar\fP _cmd = cmd; if(0){"

.PP
Definition at line 274 of file usbdrv\&.c\&.
.SS "#define USB_CFG_DESCR_PROPS_CONFIGURATION   sizeof(\fBusbDescriptorConfiguration\fP)"

.PP
Definition at line 141 of file usbdrv\&.c\&.
.SS "#define USB_CFG_DESCR_PROPS_DEVICE   sizeof(\fBusbDescriptorDevice\fP)"

.PP
Definition at line 110 of file usbdrv\&.c\&.
.SS "#define USB_CFG_DESCR_PROPS_STRING_0   sizeof(\fBusbDescriptorString0\fP)"

.PP
Definition at line 69 of file usbdrv\&.c\&.
.SS "#define USB_CFG_DESCR_PROPS_STRING_PRODUCT   sizeof(\fBusbDescriptorStringDevice\fP)"

.PP
Definition at line 88 of file usbdrv\&.c\&.
.SS "#define USB_CFG_DESCR_PROPS_STRING_VENDOR   sizeof(\fBusbDescriptorStringVendor\fP)"

.PP
Definition at line 79 of file usbdrv\&.c\&.
.SS "#define USB_FLG_MSGPTR_IS_ROM   (1<<6)"

.PP
Definition at line 52 of file usbdrv\&.c\&.
.SS "#define USB_FLG_USE_USER_RW   (1<<7)"

.PP
Definition at line 53 of file usbdrv\&.c\&.
.SS "#define USB_RX_USER_HOOK(\fBdata\fP, len)"

.PP
Definition at line 283 of file usbdrv\&.c\&.
.SS "#define USB_SET_ADDRESS_HOOK()"

.PP
Definition at line 286 of file usbdrv\&.c\&.
.SH "Function Documentation"
.PP 
.SS "\fBUSB_PUBLIC\fP void usbInit (void)"

.PP
Definition at line 607 of file usbdrv\&.c\&.
.SS "\fBUSB_PUBLIC\fP void usbPoll (void)"

.PP
Definition at line 565 of file usbdrv\&.c\&.
.SS "\fBUSB_PUBLIC\fP void usbSetInterrupt (\fBuchar\fP *data, \fBuchar\fPlen)"

.PP
Definition at line 245 of file usbdrv\&.c\&.
.SH "Variable Documentation"
.PP 
.SS "\fBuchar\fP usbConfiguration"

.PP
Definition at line 28 of file usbdrv\&.c\&.
.SS "\fBuchar\fP usbCurrentTok"

.PP
Definition at line 30 of file usbdrv\&.c\&.
.SS "\fBPROGMEM\fP char usbDescriptorConfiguration[]"

.PP
Definition at line 142 of file usbdrv\&.c\&.
.SS "\fBPROGMEM\fP char usbDescriptorDevice[]"
\fBInitial value:\fP
.PP
.nf
= {    
    18,         
    USBDESCR_DEVICE,        
    0x10, 0x01,             
    USB_CFG_DEVICE_CLASS,
    USB_CFG_DEVICE_SUBCLASS,
    0,                      
    8,                      
    
    (char)USB_CFG_VENDOR_ID,
    (char)USB_CFG_DEVICE_ID,
    USB_CFG_DEVICE_VERSION, 
    USB_CFG_DESCR_PROPS_STRING_VENDOR != 0 ? 1 : 0,         
    USB_CFG_DESCR_PROPS_STRING_PRODUCT != 0 ? 2 : 0,        
    USB_CFG_DESCR_PROPS_STRING_SERIAL_NUMBER != 0 ? 3 : 0,  
    1,          
}
.fi
.PP
Definition at line 111 of file usbdrv\&.c\&.
.SS "\fBPROGMEM\fP char usbDescriptorString0[]"
\fBInitial value:\fP
.PP
.nf
= { 
    4,          
    3,          
    0x09, 0x04, 
}
.fi
.PP
Definition at line 70 of file usbdrv\&.c\&.
.SS "\fBPROGMEM\fP int usbDescriptorStringDevice[]"
\fBInitial value:\fP
.PP
.nf
= {
    USB_STRING_DESCRIPTOR_HEADER(USB_CFG_DEVICE_NAME_LEN),
    USB_CFG_DEVICE_NAME
}
.fi
.PP
Definition at line 89 of file usbdrv\&.c\&.
.SS "\fBPROGMEM\fP int usbDescriptorStringVendor[]"
\fBInitial value:\fP
.PP
.nf
= {
    USB_STRING_DESCRIPTOR_HEADER(USB_CFG_VENDOR_NAME_LEN),
    USB_CFG_VENDOR_NAME
}
.fi
.PP
Definition at line 80 of file usbdrv\&.c\&.
.SS "\fBuchar\fP usbDeviceAddr"

.PP
Definition at line 26 of file usbdrv\&.c\&.
.SS "\fBuchar\fP usbInputBufOffset"

.PP
Definition at line 25 of file usbdrv\&.c\&.
.SS "\fBuchar\fP* usbMsgPtr"

.PP
Definition at line 48 of file usbdrv\&.c\&.
.SS "\fBuchar\fP usbNewDeviceAddr"

.PP
Definition at line 27 of file usbdrv\&.c\&.
.SS "\fBuchar\fP usbRxBuf[2 *\fBUSB_BUFSIZE\fP]"

.PP
Definition at line 24 of file usbdrv\&.c\&.
.SS "volatile \fBschar\fP usbRxLen"

.PP
Definition at line 29 of file usbdrv\&.c\&.
.SS "\fBuchar\fP usbRxToken"

.PP
Definition at line 31 of file usbdrv\&.c\&.
.SS "\fBuchar\fP usbTxBuf[\fBUSB_BUFSIZE\fP]"

.PP
Definition at line 33 of file usbdrv\&.c\&.
.SS "volatile \fBuchar\fP usbTxLen = \fBUSBPID_NAK\fP"

.PP
Definition at line 32 of file usbdrv\&.c\&.
.SS "\fBusbTxStatus_t\fP usbTxStatus1"

.PP
Definition at line 38 of file usbdrv\&.c\&.
.SH "Author"
.PP 
Generated automatically by Doxygen for Arduino Medical Assitive Device Base Station from the source code\&.
